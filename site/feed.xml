<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>林大凯的博客</title>
    <description>A ease place</description>
    <link>http://sjtuldk.tk/</link>
    <atom:link href="http://sjtuldk.tk/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 20 Aug 2014 19:11:57 +0800</pubDate>
    <lastBuildDate>Wed, 20 Aug 2014 19:11:57 +0800</lastBuildDate>
    <generator>Jekyll v2.1.1</generator>
    
      <item>
        <title>CUDA C 中的几个常用函数</title>
        <description>&lt;h3&gt;一、cudaMalloc()&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cudaMalloc(void** devPtr,  size_t cout);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;devPtr: 在显存上分配数据的头指针&lt;/p&gt;

&lt;p&gt;cout: 分配空间的大小，以字节为单位。&lt;/p&gt;

&lt;h3&gt;二、cudaMemcpy()&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cudaMemcpy(void* dst,  
           const void* src,  
           size_t count, 
           enum cudaMemcpyKind kind);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dst: 目的矩阵内存头指&lt;/p&gt;

&lt;p&gt;src：源矩阵内存头指针&lt;/p&gt;

&lt;p&gt;count: 拷贝数据的大小&lt;/p&gt;

&lt;p&gt;kind：拷贝数据的方向&lt;/p&gt;

&lt;h3&gt;三、cudaMallocPitch()&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cudaMallocPitch(void** devPtr,  
            size_t* pitch,  
            size_t widthInBytes,  
            size_t height)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;devPtr：开辟矩阵的数据的头指针&lt;/p&gt;

&lt;p&gt;pitch：分配存储器的宽度，以字节为单位(cuda的返回值)&lt;/p&gt;

&lt;p&gt;width：分配矩阵的列数&lt;/p&gt;

&lt;p&gt;height：分配矩阵的行数
注意列空间的分配需要乘上元素的大小（eg. sizeof(float)）
cudaMallocPitch()来分配global memory时，对行空间的申请回扩大到128个Bytes的整数倍。从而使每行的首地址与globla memory分段地址对齐，warp在访问的时候也就是对齐的了。&lt;/p&gt;

&lt;h3&gt;四、cudaMemcpy2D()&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cudaMemcpy2D(void* dst,
                size_t dpitch,
                const void* src,
                size_t spitch,
                size_t width,
                size_t height,
                enum cudaMemcpyKind kind);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dst: 目的矩阵内存头指针&lt;/p&gt;

&lt;p&gt;dpitch: dst指向的2D数组中的内存宽度，以字节为单位，是cuda为了读取方便，对齐过的内存宽度，可能大于一行元素占据的实际内存。&lt;/p&gt;

&lt;p&gt;src：源矩阵内存头指针&lt;/p&gt;

&lt;p&gt;spitch: src指向的2D数组中的内存宽度，以字节为单位&lt;/p&gt;

&lt;p&gt;width: src指向的2D数组中一行元素占据的实际宽度。以字节为单位，等于
width*sizeof(type)&lt;/p&gt;

&lt;p&gt;height: src指向的2D数组的行数。&lt;/p&gt;

&lt;p&gt;kind：拷贝数据的方向&lt;/p&gt;

&lt;h3&gt;五、cudaMemset()&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cudaError_t cudaMemset (void * devPtr, 
                        int value, 
                        size_t count )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;devPtr：需要赋值矩阵的头指针&lt;/p&gt;

&lt;p&gt;value：需要赋的值&lt;/p&gt;

&lt;p&gt;count：需要赋值的空间长度&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_82a790120101ka1d.html&quot;&gt;查看原文&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/08/18/CUDA-several-functions.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/08/18/CUDA-several-functions.html</guid>
        
        <category>CUDA</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>大信号放大--运放的关键参数</title>
        <description>&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;参考资料：TI学习资料SBOA126--Large-Signal Specifications for High-Voltage Line Drivers.pdf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;介绍：&lt;/h3&gt;

&lt;p&gt;对于一个运放，其带宽和信号失真性能在整个输出信号的摆幅范围内不是恒定的。
在高速运放领域中，主要有两种架构（电流反馈和电压反馈），选择电流反馈(CFB)运放还是电压反馈(VFB)运放主要取决于所需要的带宽、摆率、增益和输出电压摆幅。&lt;/p&gt;

&lt;h3&gt;电压反馈&lt;/h3&gt;

&lt;p&gt;电压反馈运放主要使用增益带宽积(GBWP)来描述：即电压增益和信号带宽的乘积是固定的（上限），但是高速VFB在低增益下却不会严格遵守这一规律，这是由于低补偿和寄生参数影响了单位增益带宽[1]，如下图中，G=1时计算的增益带宽积为800MHz，而G=10时计算的增益带宽积为300MHz，与理论值280MHz更为接近。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f1.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;h3&gt;电流反馈&lt;/h3&gt;

&lt;p&gt;电流反馈运放并没有增益带宽积这一指标。在VFB中，决定补偿的反馈参数(feedback factor)包含了两个增益控制电阻(gain-setting resistors: noninverting gain or the noise gain)。而CFB的反馈参数仅包含反馈电阻(feedback resistor)。这种架构最终导致了CFB的增益和带宽之间的无关性:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f2.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;所以，虽然CFB的单位增益带宽比VFB的单位增益带宽小很多，但是当G=10时，CFB的带宽又能够超越VFB的带宽好几倍！&lt;/p&gt;

&lt;p&gt;当然，上述分析都是基于小信号应用的分析，如果是大信号放大，则影响带宽的主要因素为运放的摆率！小信号带宽描述了大信号带宽的上限，具体能够实现的大信号带宽则由摆率限制。同时，CFB运放不仅能够在高增益下支持高带宽，同时也能比传统的双极性输入VFB达到更高的摆率！另一方面，一些slew-boosted VFB中已经开始使用了CFB的架构，但是这些运放依然受GBWP的限制。&lt;/p&gt;

&lt;p&gt;VFB和CFB更深入的比较可以参考Ref. 2&lt;/p&gt;

&lt;h3&gt;摆率&lt;/h3&gt;

&lt;p&gt;摆率是一个针对大信号的参数，应当将其与两个小信号参数：上升时间和下降时间加以区分。&lt;/p&gt;

&lt;p&gt;比如：THS3091在G=5，输出20V时的摆率为7300V/μs，所以输出电压摆动20V所需要的时间为2.7ns(20V/7300V/μs=2.7ns)。然而，实际输出电压摆动20V所需要的时间要大于2.7ns，因为摆率是在输出范围的25%~75%（或10%~90%）的范围内测得的，即对于一个脉冲信号，摆率是在其上升沿中部测量的，而不是整个脉冲的上升时间：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f3.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;对于一个大信号正弦波，已知摆率和输出信号幅度，可以计算该运放所能处理的最高频率：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f4.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;当摆率无法支持信号频率时，op放大器将会进入开环状态（运放无法将误差信号减小）。此时，fmax被称为“无摆率限制带宽”&lt;/p&gt;

&lt;p&gt;需要注意的是“无摆率限制带宽”和3dB带宽是不同的，“无摆率限制带宽”可以很明显地在输出信号波形中观察出来（正弦波?三角波）。&lt;/p&gt;

&lt;p&gt;然而，上述计算“无摆率限制带宽”的方法似乎并没有计算3dB带宽的方法那样普适，因此，原始的SR=2πf*Vp可以改写为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f5.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，摆率只考虑信号80%的部分（10%~90%），因此可以用因子0.8来修正摆率的计算式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f6.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;正是由于这种测量区间所带来的影响，由上式所计算的摆率通常并不能表示运放的摆率上限。为了达到80-dBc的失真水平，应当原则摆率比最大信号情况高20倍的运放！&lt;/p&gt;

&lt;h3&gt;对于仿真的警示：&lt;/h3&gt;

&lt;p&gt;由于仿真软件使用的都是元件的线性模型，而且电路的频率响应都是使用无限小的输入信号来计算的，因此ac扫描并不能描述op放大器的任何大信号频率响应。时域分析和冲击响应的仿真则能够更好地反映大信号情况下的现象。&lt;/p&gt;

&lt;h3&gt;输出电压摆幅和输出电流&lt;/h3&gt;

&lt;p&gt;为大信号放大选择op放大器时所需要考虑的最后一个重要因素为输出电压的摆幅和输出电流。&lt;/p&gt;

&lt;p&gt;由于op放大器的输出电阻在电压输出时需要从供电电源处获取一部分分压，因此限制了输出摆幅（运放的双轨？？）。同时，运放的输出电压摆幅也受运放的输出电流限制：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f7.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;h3&gt;总结：&lt;/h3&gt;

&lt;p&gt;摆率、输出电压摆幅、输出电流都对运放的带宽和失真有着很大的影响！&lt;/p&gt;

&lt;h3&gt;参考资料：&lt;/h3&gt;

&lt;p&gt;[1] Ramus, X. (2009). Making the most of a low-power, high-speed operational amplifier. Texas
Instruments application report SBOA121.
[2] Karki, J. (1998). Voltage feedback vs current feedback op amps. Texas Instruments application report SLVA051.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/21/Large-signal-parameters.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/21/Large-signal-parameters.html</guid>
        
        <category>OP-Amp</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>大信号放大--运放的关键参数</title>
        <description>&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;参考资料：TI学习文档SBOA126：Large-Signal Specifications for High-Voltage Line Drivers.pdf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;介绍：&lt;/h3&gt;

&lt;p&gt;对于一个运放，其带宽和信号失真性能在整个输出信号的摆幅范围内不是恒定的。
在高速运放领域中，主要有两种架构（电流反馈和电压反馈），选择电流反馈(CFB)运放还是电压反馈(VFB)运放主要取决于所需要的带宽、摆率、增益和输出电压摆幅。&lt;/p&gt;

&lt;h3&gt;电压反馈&lt;/h3&gt;

&lt;p&gt;电压反馈运放主要使用增益带宽积(GBWP)来描述：即电压增益和信号带宽的乘积是固定的（上限），但是高速VFB在低增益下却不会严格遵守这一规律，这是由于低补偿和寄生参数影响了单位增益带宽[1]，如下图中，G=1时计算的增益带宽积为800MHz，而G=10时计算的增益带宽积为300MHz，与理论值280MHz更为接近。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f1.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;h3&gt;电流反馈&lt;/h3&gt;

&lt;p&gt;电流反馈运放并没有增益带宽积这一指标。在VFB中，决定补偿的反馈参数(feedback factor)包含了两个增益控制电阻(gain-setting resistors: noninverting gain or the noise gain)。而CFB的反馈参数仅包含反馈电阻(feedback resistor)。这种架构最终导致了CFB的增益和带宽之间的无关性:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f2.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;所以，虽然CFB的单位增益带宽比VFB的单位增益带宽小很多，但是当G=10时，CFB的带宽又能够超越VFB的带宽好几倍！&lt;/p&gt;

&lt;p&gt;当然，上述分析都是基于小信号应用的分析，如果是大信号放大，则影响带宽的主要因素为运放的摆率！小信号带宽描述了大信号带宽的上限，具体能够实现的大信号带宽则由摆率限制。同时，CFB运放不仅能够在高增益下支持高带宽，同时也能比传统的双极性输入VFB达到更高的摆率！另一方面，一些slew-boosted VFB中已经开始使用了CFB的架构，但是这些运放依然受GBWP的限制。&lt;/p&gt;

&lt;p&gt;VFB和CFB更深入的比较可以参考Ref. 2&lt;/p&gt;

&lt;h3&gt;摆率&lt;/h3&gt;

&lt;p&gt;摆率是一个针对大信号的参数，应当将其与两个小信号参数：上升时间和下降时间加以区分。&lt;/p&gt;

&lt;p&gt;比如：THS3091在G=5，输出20V时的摆率为7300V/μs，所以输出电压摆动20V所需要的时间为2.7ns(20V/7300V/μs=2.7ns)。然而，实际输出电压摆动20V所需要的时间要大于2.7ns，因为摆率是在输出范围的25%~75%（或10%~90%）的范围内测得的，即对于一个脉冲信号，摆率是在其上升沿中部测量的，而不是整个脉冲的上升时间：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f3.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;对于一个大信号正弦波，已知摆率和输出信号幅度，可以计算该运放所能处理的最高频率：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f4.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;当摆率无法支持信号频率时，op放大器将会进入开环状态（运放无法将误差信号减小）。此时，fmax被称为“无摆率限制带宽”&lt;/p&gt;

&lt;p&gt;需要注意的是“无摆率限制带宽”和3dB带宽是不同的，“无摆率限制带宽”可以很明显地在输出信号波形中观察出来（正弦波三角波）。&lt;/p&gt;

&lt;p&gt;然而，上述计算“无摆率限制带宽”的方法似乎并没有计算3dB带宽的方法那样普适，因此，原始的SR=2πf*Vp可以改写为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f5.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，摆率只考虑信号80%的部分（10%~90%），因此可以用因子0.8来修正摆率的计算式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f6.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;正是由于这种测量区间所带来的影响，由上式所计算的摆率通常并不能表示运放的摆率上限。为了达到80-dBc的失真水平，应当原则摆率比最大信号情况高20倍的运放！&lt;/p&gt;

&lt;h3&gt;对于仿真的警示：&lt;/h3&gt;

&lt;p&gt;由于仿真软件使用的都是元件的线性模型，而且电路的频率响应都是使用无限小的输入信号来计算的，因此ac扫描并不能描述op放大器的任何大信号频率响应。时域分析和冲击响应的仿真则能够更好地反映大信号情况下的现象。&lt;/p&gt;

&lt;h3&gt;输出电压摆幅和输出电流&lt;/h3&gt;

&lt;p&gt;为大信号放大选择op放大器时所需要考虑的最后一个重要因素为输出电压的摆幅和输出电流。&lt;/p&gt;

&lt;p&gt;由于op放大器的输出电阻在电压输出时需要从供电电源处获取一部分分压，因此限制了输出摆幅（运放的双轨？？）。同时，运放的输出电压摆幅也受运放的输出电流限制：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Big-signal-parameters/f7.jpg&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;h3&gt;总结：&lt;/h3&gt;

&lt;p&gt;摆率、输出电压摆幅、输出电流都对运放的带宽和失真有着很大的影响！&lt;/p&gt;

&lt;h3&gt;补充资料：&lt;/h3&gt;

&lt;p&gt;[1] Ramus, X. (2009). Making the most of a low-power, high-speed operational amplifier. Texas
Instruments application report SBOA121.
[2] Karki, J. (1998). Voltage feedback vs current feedback op amps. Texas Instruments application report SLVA051.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/21/Large-signal-parameters.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/21/Large-signal-parameters.html</guid>
        
        <category>OP-Amp</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>CV-QKD的安全距离</title>
        <description>&lt;h1&gt;高频大信号放大解决方案：共享负载&lt;/h1&gt;

&lt;h3&gt;一、什么是“大信号”&lt;/h3&gt;

&lt;p&gt;对于±5V供电的运放，2Vpp即为大信号
对于±15V供电的运放，5Vpp即为大信号
然而，大信号的实际表现需要根据实际情况确定：
    比如对于ADC驱动放大器，如低电压，±5V供电，全差分电压反馈放大器，则指定大信号带宽为2Vpp，因为2Vpp是通常情况下的ADC信号幅度。
    另一方面，一个高电压正负28V电流反馈放大器(THS6204)，则大信号应用为4Vpp到20Vpp输出。
实际上，输出电压摆幅对于信号带宽的限制作用大于50%。
在大信号应用中，&lt;strong&gt;电压摆率&lt;/strong&gt;对信号带宽的影响更大！&lt;/p&gt;

&lt;h3&gt;二、摆率、输出电压摆幅、输出电流&lt;/h3&gt;

&lt;p&gt;三者是大信号应用中的关键参数，尤其是需要输出信号的失真很小时。以下简要总结它们之间的关系：
1. 摆率和大信号带宽直接相关。同时也与放大器的失真相关。从经验上讲，要支持一个80dBc(用来度量信号与载波功率之间的比值)的信号，则需要运放的摆率需要是能够支持该频率信号的摆率的20倍！
2. 放大器输出电流带载(output current sourcing and sinking ability into the load)能力决定了输出电压的摆幅。负载电流越大则失真越严重。另外，高速大摆幅信号加载到容性负载上时需要快速地对电容充放电，对于这种容性负载，运放有限的带载能力所带来的不足可以等同于视为摆率的降低。
3. 摆幅接近运放的双轨时输出同样会失真。&lt;/p&gt;

&lt;h3&gt;三、负载共享运放&lt;/h3&gt;

&lt;p&gt;一个实际应用：
&lt;img src=&quot;/public/upload/Load-sharing/f1.png&quot; alt=&quot;interpreter pattern&quot;&gt;
    其中，两个运放的输出端均连接了100Ω的电阻，这样从GND看这两个电阻并联，并与50Ω的负载相匹配。
    输出端的阻抗匹配嫩巩固使负载端的反射最小，也造成了6dB的负载端信号衰减。
    输入端的匹配同样通过两个100Ω的电阻并联实现。
    在实际应用中，即使不需要终端匹配和反向终端(back or double termination)，在两个运放的输出端放置一个电阻仍然是有必要的，它们能够使两个运放的输出电流达到平衡，防止反灌现象。&lt;/p&gt;

&lt;h3&gt;四、 输出直流偏置&lt;/h3&gt;

&lt;p&gt;共享负载的应用需要避免运放之间的电流传输，否则会给整个电路造成致命伤害！
    同时，即使由于共享负载使得每个运放的输出电流减小了，但是输出电压摆幅的要求却始终没变！
    造成输出不均衡的一个原因便是输出信号的直流偏置。计算公式可参照《tidu153.pdf—P4》。
    虽然双运放封装的放大器相对于单运放封装的运放具有更好的匹配特性，但是由于共享电源的不相互独立的限制，导致双运放封装并不适合在应用在共享负载中。这是由于它们共用一根电源管脚，可能会导致相互之间的正反馈（positive feedback）并进而导致振荡。选择单运放封装的另一个原因是散热问题，单运放封装可以的每个运放可以承载更大的功率。
&lt;strong&gt;ps:&lt;/strong&gt;a double-terminated, 50 Ω cable：
&lt;img src=&quot;/public/upload/Load-sharing/f2.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/18/Load-sharing.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/18/Load-sharing.html</guid>
        
        <category>CV-QKD</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>分层LDPC译码算法</title>
        <description>&lt;p&gt;传统的LDPC译码常用Belief propagation即置信传播算法，但是其译码却相对复杂。虽然也存在一些简化的LDPC译码算法，比如上一篇文章这种提到的集中方法，但是简化算法一方面降低了算法的性能，另一方面并不是提高LDPC译码速度的长久之计（不可能通过无限制的简化不断提高速度）。所以就有了本文要介绍的分层译码算法（layered decoding）。&lt;/p&gt;

&lt;p&gt;介绍分层译码算法前再简单介绍下LDPC码：产生LDPC码（即LDPC编码）有很多种方法，但每一种编码方法都可以用校验矩阵H表示。某些编码方法的H采用完全随机构造的方法，一般具有比较好的性能。另一些则采用结构化的方法（structured code），结构化使得译码更简单，译码速率更快。
分层译码算法针对的就是结构化的H矩阵。&lt;/p&gt;

&lt;p&gt;结构化的H矩阵可以看成是由不同的层（layer）组成的，每层通常都包含H矩阵的几行。因为可以将整个H矩阵的译码拆分成不同层来译码，因此使得一码过程中消息更新的速度更快，可以减少迭代次数，另一方面，层与层之间的部分操作在时间上式可重叠的，因此可以进一步提高速度，这样同时也能降低硬件开销和功耗。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;之前的错误理解&lt;/strong&gt;：因为层与层之间相互独立，因此可以分别译码，这就使整个译码过程由大化小，并进一步可以使用并行处理的方式加快一码速度，这就是分层一码算法的精髓。&lt;/p&gt;

&lt;p&gt;对于H矩阵的每一层，可以使用软输入-软输出（SISO，soft-input soft-output）译码器实现译码（软是指数据的格式是浮点数吧，即没有可枚举的输入输出态，希望没理解错）。&lt;/p&gt;

&lt;p&gt;在结构化LDPC的译码中关于迭代有两个概念，一是“子迭代（sub-iteration）”，是指层与层之间的迭代，另一个是“超迭代（super-iteration）”，是指整个H矩阵的循环迭代。&lt;/p&gt;

&lt;p&gt;然后介绍下关于结构化LDPC译码的几个关键性人物及其研究：&lt;/p&gt;

&lt;p&gt;Boutros, et al., 他们将这种译码方法应用于普通的LDPC码。他们码的构成中，每一层由若干不重叠的“部件码”（component code）（如BCH码）组成。每一层的译码通过对每个“部件码”进行SISO译码实现，一层中的各个“部件码”相互独立，因此可以分开译码。所使用的SISO译码器可以是对应“部件码”的对应译码器或者是基于这部分校验矩阵的BP译码器。&lt;/p&gt;

&lt;p&gt;Behairy and Chang，将分层译码器应用于将LDPC码并将校验矩阵分成水平的两层。每一层都是具有独自特性的LDPC码。在这种情况下，每一层的译码都使用BP译码。
Li, et al., 对他们的乘积累加码（product accumulate code）的outer code（怎么翻译？？）使用两层译码。后来该方法又普遍化为任意层数。虽然他们将其outer code称为turbo product 码，这种码同样可以视为是分层的LDPC码。每一层是乘积码的一个维度（dimension）。他们对每一层都使用BP译码。然而，每一层的列重最多为1，因此每一层中最多只能使用1次迭代。&lt;/p&gt;

&lt;p&gt;Mansour and Shanbhag，扩展了分层译码技术的应用并使之更加流行。他们的设计中每层的列重同样为1。他们的LDPC码的校验矩阵由更小的block组成，每个block矩阵都是移位矩阵。他们在研究中发现了对这种分层译码技术需要减小迭代次数，这和不使用分层译码的BP译码不同。&lt;/p&gt;

&lt;p&gt;然后介绍一种分层的BP译码方法的实现方式：使用时间重叠列求和的方法（using time-overlapped column summation）。在这种方法中，最新更新的Lrij能够迅速被算法重新利用（即上面提到的加快消息更新速度）。假定将行分为互不重叠的subset，其中每个subset满足：这个subset对应的校验矩阵中的列部分的列重最多为1。同时每个subset被视为一个单元依次译码。具体可参考下图1：H矩阵被分成了4层，每一层由4个子矩阵构成，但这里的子矩阵并不是subset，再参考图2：即每个子矩阵为4*4的矩阵，因此原来H矩阵的每行被4个子矩阵分割，而每一行被分割成了4个subset（希望没错）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Layered-LDPC/f1.png&quot; alt=&quot;interpreter pattern&quot;&gt;
&lt;img src=&quot;/public/upload/Layered-LDPC/f2.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;至此分层LDPC译码技术算是大致介绍完了，需要注意的是其中的并行思想并不是指每一层都能够单独译码，因为层与层之间存在消息传递的约束，因此是由先后顺序的！&lt;/p&gt;

&lt;p&gt;这里的并行处理就如图2所示的是指每层的不同行是可以并行计算的。层与层之间可以有部分操作时时间重叠的（最前面提到过），这种方法也可以称之为流水线式译码（pipelined decoding），如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/Layered-LDPC/f3.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/18/Layered-LDPC.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/18/Layered-LDPC.html</guid>
        
        <category>LDPC</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>通用Matlab加速方法</title>
        <description>&lt;ol&gt;
&lt;li&gt; 向量化运算，如max(X,2)为将X中大于2的值都赋值为2，而不需要循环判断每个元素的大小再赋值。&lt;/li&gt;
&lt;li&gt; 预分配空间，循环中不断改变变量大小需要反复申请空间。&lt;/li&gt;
&lt;li&gt; 尽量避免for循环，而使用矩阵运算代替之。在不能避免for循环的情况下，要注意循环顺序应该是先按列循环（遍历完第一列再遍历第二列），这是因为Matlab延续了Fortran语言的习惯，矩阵是按列的顺序存储的。这种循环方式在矩阵阶数越高的情况下提速越明显。&lt;/li&gt;
&lt;li&gt; 对于稀疏矩阵，考虑使用sparse()函数，避免大量无意义运算。&lt;/li&gt;
&lt;li&gt; 在程序提速的同时要同时兼顾可读性，这样才能节省出更多调试时间来思考更有效的算法，并享受精彩人生！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tips：
1.  初始化一个全0矩阵X，则X(M,N)=0;比X=zeros(M,N)要快！缺点是后续清零的时候还是要用zeros，否则将出现BUG！&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Jul 2014 05:04:50 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/13/Matlab-speedup.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/13/Matlab-speedup.html</guid>
        
        <category>Matlab</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Matlab中的CUDA环境配置小记</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;参考书籍《Accelerating MATLAB with GPU Computing》—Chapter 2.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先根据系统情况下载CUDA安装包并安装。&lt;/p&gt;

&lt;p&gt;安装完毕后再Matlab中输入：
    &amp;gt;&amp;gt; system(&amp;#39;nvcc&amp;#39;);&lt;/p&gt;

&lt;p&gt;正常情况下会返回值:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;nvcc : fatal error : No input files specified; use option --help for more information 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这是正常现象，如果返回值为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;nvcc is not recognized as an 26 Accelerating MATLAB with GPU Computing internal or external command, operable program or batch file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则可能是由于CUDA没有正确安装&lt;/p&gt;

&lt;p&gt;根据教程，接着在Matlab中新建一个&lt;strong&gt;AddVectors.h&lt;/strong&gt;文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;#&lt;span class=&quot;n&quot;&gt;ifndef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__ADDVECTORS_H__&lt;/span&gt;
#&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__ADDVECTORS_H__&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addVectors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
#&lt;span class=&quot;n&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__ADDVECTORS_H__&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再建立一个&lt;strong&gt;AddVectors.cu&lt;/strong&gt;文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-matlab&quot; data-lang=&quot;matlab&quot;&gt;#&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &amp;quot;&lt;span class=&quot;n&quot;&gt;AddVectors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&amp;quot;
#&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &amp;quot;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Program&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Files&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MATLAB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R2012b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&amp;quot;


&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addVectorsMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addVectors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrA&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrC&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyHostToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyHostToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;addVectorsMask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devPtrC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyDeviceToHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devPtrC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据教程，下一步为执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;system(&amp;#39;nvcc -c AddVectors.cu&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这时问题就出现了，Matlab可能会提示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;nvcc : fatal error : Cannot find compiler &amp;#39;cl.exe&amp;#39; in PATH 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是Matlab在现有的路径中并没有找到VS 2010用来编译的cl.exe，本来想试着如何将VS的目录包含进去，但是试过在环境变量PATH中添加VS目录以用及Mex -setup连接VS环境后，错误均未解决，因此采用就书中提及的 &lt;strong&gt;-ccbin&lt;/strong&gt; 选项（为了以后编程方便，建议将VS的bin目录和Matlab的\extern\include目录添加到环境变量PATH中）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;system(&amp;#39;nvcc -c AddVectors.cu -ccbin &amp;quot;C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin&amp;quot;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是就可以正确编译生成.obj文件了。
最开始编译的时候还遇到了无法打开“mex.h”的错误：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fatal error C1083: 无法打开包括文件:“mex.h”: No such file or directory 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AddVectors.cu &lt;/p&gt;

&lt;p&gt;可以通过将刚刚编写的&lt;strong&gt;AddVectors.cu&lt;/strong&gt;文件中的#include “mex.h”添加路径指向：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#include &amp;quot;D:\Program Files\MATLAB\R2012b\extern\include\mex.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;期间还遇到过无法打开“tmwtypes.h”的错误:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; fatal error C1083: 无法打开包括文件:“tmwtypes.h”: No such file or directory 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终参考&lt;a href=&quot;http://www.muzichao.com/matlab-cuda-2/&quot;&gt;木子超同学的博文&lt;/a&gt;，将#include &lt;tmwtypes.h&gt;改为#include &amp;quot;tmwtypes.h&amp;quot;后通过编译：&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/13/Matlab-CUDA2.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/13/Matlab-CUDA2.html</guid>
        
        <category>Matlab</category>
        
        <category>CUDA</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>CV-QKD的安全距离</title>
        <description>&lt;p&gt;首先,影响&lt;strong&gt;安全距离&lt;/strong&gt;的物理量有: 调制方差Va 、检测器效率η 、电噪声Vel、通信距离L以及信道衰减系数α，通常情况下α为0.2dB/Km。
由于要考虑的是安全距离，那么就必然要考虑窃听者，若值考虑单独攻击(individual attack)和联合攻击(coherent attack)，由此，安全距离的定义为：在窃听者Eve的攻击下，发送者Alice和接受者Bob依然能够使安全密钥率R大于0 。
密钥率通过Alice和Bob之间的互信息I(A:B)以及Eve所能窃听的信息I(B:E)来确定（此处假定系统为反向协商），即：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/f1.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;关于individual attack和coherent attack 下Eve能够获取的互信息I(B:E)可以参考论文：“Improvement of continuous-variable quantum key distribution systems by using optical preamplifiers，S Fossier，EDiamanti，2009”
现直接引用结论：
Individual attack 下使用Homodyne检测器时的I(A:B)和I(B:E)分别为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/f2.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/f3.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;img src=&quot;/public/upload/CV-QKD-Distance/f4.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;公式中的其它参数为：
T表示信道传输系数（信道透过率），给定T和Vel后可以得知Bob端检测器的输入噪声方差为（1+T&lt;em&gt;Vel）&lt;/em&gt;N0，N0为信道的shot noise，可看成一个单位（调制方差Va的单位也是N0）。
进一步可以计算信道总的加性噪声为&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/1405177070912.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;当然，系统中除了信道的噪声外还有检测器噪声（这里只分析Homodyne检测器）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/1405177076102.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;那么总噪声为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/1405177085654.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;公式中的V=Va+1，Va为Alice的调制方差&lt;/p&gt;

&lt;p&gt;信道传输系数T=10^(-0.2*L/10)，L为传输距离，单位为km。&lt;/p&gt;

&lt;p&gt;至此，就可以利用上面的式子计算induvidual attack下使用Homodyne检测器时的I(A:B)和I(B:E)了，但是此时已然不能根据上面的R=I(A:B)-I(B:E)&amp;gt;0就判断能够安全通信。这是因为在后处理阶段，通过量子协商算法进行密钥协商时存在协商效率β，因此R的最终表达式应该是：
    R=β*I(A:B)-I(B:E)
    那么，再结合自己的协商算法的效率，便可以知道安全距离能够达到多少了。&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/12/CVQKD.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/12/CVQKD.html</guid>
        
        <category>CV-QKD</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>CV-QKD的安全距离</title>
        <description>&lt;p&gt;首先,影响&lt;strong&gt;安全距离&lt;/strong&gt;的物理量有: 调制方差Va 、检测器效率η 、电噪声Vel、通信距离L以及信道衰减系数α，通常情况下α为0.2dB/Km。
由于要考虑的是安全距离，那么就必然要考虑窃听者，若值考虑单独攻击(individual attack)和联合攻击(coherent attack)，由此，安全距离的定义为：在窃听者Eve的攻击下，发送者Alice和接受者Bob依然能够使安全密钥率R大于0 。
密钥率通过Alice和Bob之间的互信息I(A:B)以及Eve所能窃听的信息I(B:E)来确定（此处假定系统为反向协商），即：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/f1.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;关于individual attack和coherent attack 下Eve能够获取的互信息I(B:E)可以参考论文：“Improvement of continuous-variable quantum key distribution systems by using optical preamplifiers，S Fossier，EDiamanti，2009”
现直接引用结论：
Individual attack 下使用Homodyne检测器时的I(A:B)和I(B:E)分别为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/f2.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/f3.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;img src=&quot;/public/upload/CV-QKD-Distance/f4.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;公式中的其它参数为：
T表示信道传输系数（信道透过率），给定T和Vel后可以得知Bob端检测器的输入噪声方差为（1+T&lt;em&gt;Vel）&lt;/em&gt;N0，N0为信道的shot noise，可看成一个单位（调制方差Va的单位也是N0）。
进一步可以计算信道总的加性噪声为&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/1405177070912.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;当然，系统中除了信道的噪声外还有检测器噪声（这里只分析Homodyne检测器）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/1405177076102.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;那么总噪声为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/CV-QKD-Distance/1405177085654.png&quot; alt=&quot;interpreter pattern&quot;&gt;&lt;/p&gt;

&lt;p&gt;公式中的V=Va+1，Va为Alice的调制方差&lt;/p&gt;

&lt;p&gt;信道传输系数T=10^(-0.2*L/10)，L为传输距离，单位为km。&lt;/p&gt;

&lt;p&gt;至此，就可以利用上面的式子计算induvidual attack下使用Homodyne检测器时的I(A:B)和I(B:E)了，但是此时已然不能根据上面的R=I(A:B)-I(B:E)&amp;gt;0就判断能够安全通信。这是因为在后处理阶段，通过量子协商算法进行密钥协商时存在协商效率β，因此R的最终表达式应该是：
    R=β*I(A:B)-I(B:E)
    那么，再结合自己的协商算法的效率，便可以知道安全距离能够达到多少了。&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/07/12/CV-QKD-Distance.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/07/12/CV-QKD-Distance.html</guid>
        
        <category>CV-QKD</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>错误设计的蒲公英</title>
        <description>&lt;p&gt;一、&lt;/p&gt;

&lt;p&gt;看看那满河面随风而去的蒲公英吧&lt;/p&gt;

&lt;p&gt;你是否会觉得：&lt;/p&gt;

&lt;p&gt;大自然在用一种极低的效率做着一件极简单的事情？&lt;/p&gt;

&lt;p&gt;但也请你看看草地上那满满的白色精灵,&lt;/p&gt;

&lt;p&gt;紧紧地依附着土地,&lt;/p&gt;

&lt;p&gt;那又是多么盎然的生机？&lt;/p&gt;

&lt;p&gt;如果让人类用几千万年的时间去优化蒲公英的机理，&lt;/p&gt;

&lt;p&gt;会不会给蒲公英植入自动寻找泥土的基因？&lt;/p&gt;

&lt;p&gt;再使用全局规划的算法，&lt;/p&gt;

&lt;p&gt;来决定向东南西北飞翔的比例？&lt;/p&gt;

&lt;p&gt;最后每一片蒲公英都成了一个精致而复杂的系统，&lt;/p&gt;

&lt;p&gt;并随之产生了更多的问题。&lt;/p&gt;

&lt;p&gt;啊！&lt;/p&gt;

&lt;p&gt;多么愚蠢的决定。&lt;/p&gt;

&lt;p&gt;看看大自然吧，&lt;/p&gt;

&lt;p&gt;它正在以多么简单的方式，&lt;/p&gt;

&lt;p&gt;让蒲公英飞得如此美丽。&lt;/p&gt;

&lt;p&gt;二、&lt;/p&gt;

&lt;p&gt;再看看那随波而去的白色精灵吧，&lt;/p&gt;

&lt;p&gt;它们可能成为鱼虾的美食，&lt;/p&gt;

&lt;p&gt;也有可能再次被鸟儿携去，&lt;/p&gt;

&lt;p&gt;落入某片不知名的土地。&lt;/p&gt;

&lt;p&gt;它们有着各自不同的命运，&lt;/p&gt;

&lt;p&gt;相互却从不较劲。&lt;/p&gt;

&lt;p&gt;这是它们懂得的逻辑，&lt;/p&gt;

&lt;p&gt;不在乎命运是否公平。&lt;/p&gt;

&lt;p&gt;也许彼此全然不同的遭遇，&lt;/p&gt;

&lt;p&gt;只是为了全然不同的奇迹。&lt;/p&gt;

&lt;p&gt;而人类却总是不懂这层关系，&lt;/p&gt;

&lt;p&gt;追求公平，维持公平。&lt;/p&gt;

&lt;p&gt;这究竟是大自然错误地设计了人类？&lt;/p&gt;

&lt;p&gt;还是说，&lt;/p&gt;

&lt;p&gt;人类才是大自然错误设计的蒲公英。&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://sjtuldk.tk/2014/06/19/dandelion.html</link>
        <guid isPermaLink="true">http://sjtuldk.tk/2014/06/19/dandelion.html</guid>
        
        <category>Life</category>
        
        
        <category>生活</category>
        
      </item>
    
  </channel>
</rss>
